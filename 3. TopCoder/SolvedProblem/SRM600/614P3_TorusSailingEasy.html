<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><p>
Fox Ciel is sailing in the Donut sea. The Donut sea is a torus. For navigation, the torus is divided into <b>N</b> times <b>M</b> cells, as shown in the figure below.
</p>
<br></br>
<p>
<img src="http://www.topcoder.com/contest/problem/TorusSailing/torus.png"></img><br></br>
<i>(Image by YassineMrabet from Wikimedia Commons, licensed under CC BY-SA 3.0.)</i>
</p>
<br></br>
<p>
Each of the cells has two integer coordinates (n, m), where 0 &lt;= n &lt; <b>N</b> and 0 &lt;= m &lt; <b>M</b>. Note that the coordinates wrap around modulo <b>N</b> and <b>M</b>. For example, if you are in the cell (<b>N</b>-1, <b>M</b>-1) and you cross over one of its sides, you will reach one of the cells (<b>N</b>-2, <b>M</b>-1), (0, <b>M</b>-1), (<b>N</b>-1, <b>M</b>-2), and (<b>N</b>-1, 0).
</p>
<br></br>
<p>
Ciel starts in the cell (0, 0) and wants to reach the goal cell (<b>goalX</b>, <b>goalY</b>).
</p>
<br></br>
<p>
Unfortunately, Ciel's navigation is very poor. Whenever she moves to a new cell, there are two equally probable outcomes: either both of her coordinates increase by 1, or both of them decrease by 1 (wrapping around if necessary). Formally, if Ciel's current coordinates are (n, m), her new coordinates will be either ((n+1) modulo <b>N</b>, (m+1) modulo <b>M</b>), or ((n-1) modulo <b>N</b>, (m-1) modulo <b>M</b>), with equal probability. Each such move takes one day.
</p>
<br></br>
<p>
If Ciel can never reach her goal, return -1. Otherwise, return the expected number of days Ciel will need to reach her goal.
</p>
</td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>TorusSailingEasy</td></tr><tr><td>Method:</td><td>expectedTime</td></tr><tr><td>Parameters:</td><td>int, int, int, int</td></tr><tr><td>Returns:</td><td>double</td></tr><tr><td>Method signature:</td><td>double expectedTime(int N, int M, int goalX, int goalY)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Notes</h3></td></tr><tr><td align="center" valign="top">-</td><td>The returned value must have an absolute or relative error less than 1e-9.</td></tr><tr><td align="center" valign="top">-</td><td>In many programming languages the modulo operator returns negative values for negative inputs. If you are using such a language, it is safer to use the formulas ((n-1+<b>N</b>) modulo <b>N</b>) and ((m-1+<b>M</b>) modulo <b>M</b>) to compute Ciel's new coordinates when both of them are supposed to decrease.</td></tr><tr><td align="center" valign="top">-</td><td>Informally, the expected value of a random variable can be seen as its average over very many trials.</td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><b>N</b> will be between 2 and 10, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>M</b> will be between 2 and 10, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>goalX</b> will be between 0 and <b>N</b> - 1, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>goalY</b> will be between 0 and <b>M</b> - 1, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>(<b>goalX</b>, <b>goalY</b>) will not be (0, 0).</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>2</pre></td></tr><tr><td><pre>2</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>1</pre></td></tr></table></td></tr><tr><td><pre>Returns: 1.0</pre></td></tr><tr><td><table><tr><td colspan="2">She will always reach the goal in 1 day.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>2</pre></td></tr><tr><td><pre>2</pre></td></tr><tr><td><pre>0</pre></td></tr><tr><td><pre>1</pre></td></tr></table></td></tr><tr><td><pre>Returns: -1.0</pre></td></tr><tr><td><table><tr><td colspan="2">It is impossible to reach the goal. Ciel will only visit the cells (0, 0) and (1, 1) alternately.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>3</pre></td></tr><tr><td><pre>3</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>1</pre></td></tr></table></td></tr><tr><td><pre>Returns: 2.0</pre></td></tr><tr><td><table><tr><td colspan="2"><p>She can reach the goal in 1 day with probability 1/2, in 2 days with probability 1/4, in 3 days with probability 1/8, in 4 days with probability 1/16 and so on. In general, she can reach the goal in n days with probability 1/(2^n) where n is a positive integer.</p>
<p>
The answer is (1 * 1/2) + (2 * 1/4) + (3 * 1/8) + (4 * 1/16) + ... = 2.0.
</p></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>4</pre></td></tr><tr><td><pre>6</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>3</pre></td></tr></table></td></tr><tr><td><pre>Returns: 27.0</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>
